// ========================================
// Cookie Retry Handler
// X·ª≠ l√Ω retry khi cookie l·ªói
// ========================================

class CookieRetryHandler {
    constructor(backendUrl, authToken) {
        this.backendUrl = backendUrl;
        this.authToken = authToken;
        this.maxRetries = 5;
        this.currentRetry = 0;
        this.usedCookies = new Set();
    }
    
    /**
     * Th·ª≠ login v·ªõi cookie, t·ª± ƒë·ªông retry n·∫øu l·ªói
     */
    async attemptLogin(onProgress) {
        this.currentRetry = 0;
        this.usedCookies.clear();
        
        while (this.currentRetry < this.maxRetries) {
            this.currentRetry++;
            
            try {
                // Update progress
                if (onProgress) {
                    onProgress({
                        status: 'trying',
                        attempt: this.currentRetry,
                        maxAttempts: this.maxRetries,
                        message: `ƒêang th·ª≠ ƒëƒÉng nh·∫≠p (l·∫ßn ${this.currentRetry}/${this.maxRetries})...`
                    });
                }
                
                // Get cookie from backend
                const cookieData = await this.getCookieFromBackend();
                
                if (!cookieData) {
                    throw new Error('Kh√¥ng c√≥ cookie kh·∫£ d·ª•ng');
                }
                
                // Try to inject cookie
                const result = await this.injectCookieAndCheck(cookieData);
                
                if (result.success) {
                    // Success! Confirm cookie assignment (tƒÉng slot +1)
                    console.log('üéâ Login successful! Confirming cookie assignment...');
                    await this.confirmCookie(cookieData.cookieId);
                    
                    if (onProgress) {
                        onProgress({
                            status: 'success',
                            message: 'ƒêƒÉng nh·∫≠p th√†nh c√¥ng!',
                            cookieNumber: cookieData.cookieNumber
                        });
                    }
                    return { success: true, cookieData };
                }
                
                // Failed - mark cookie as dead (KH√îNG tƒÉng slot)
                console.log('‚ùå Login failed, marking cookie as dead...');
                await this.markCookieAsDead(cookieData.cookieId, result.errorCode);
                
                // Add to used list
                this.usedCookies.add(cookieData.cookieId);
                
                // Update progress
                if (onProgress) {
                    onProgress({
                        status: 'retrying',
                        attempt: this.currentRetry,
                        maxAttempts: this.maxRetries,
                        message: `Cookie #${cookieData.cookieNumber} l·ªói, ƒëang th·ª≠ cookie kh√°c...`,
                        errorCode: result.errorCode
                    });
                }
                
                // Wait before retry
                await this.sleep(2000);
                
            } catch (error) {
                console.error(`‚ùå Attempt ${this.currentRetry} failed:`, error);
                
                if (this.currentRetry >= this.maxRetries) {
                    // Out of retries
                    console.log('‚ùå Reached max retries');
                    console.log('‚ö†Ô∏è No cookie was assigned (all failed)');
                    
                    if (onProgress) {
                        onProgress({
                            status: 'failed',
                            message: 'ƒêƒÉng nh·∫≠p th·∫•t b·∫°i. Vui l√≤ng th·ª≠ l·∫°i sau.',
                            error: error.message
                        });
                    }
                    return { success: false, error: error.message };
                }
            }
        }
        
        // Max retries reached
        console.log('‚ùå Max retries reached');
        console.log('‚ö†Ô∏è No cookie was assigned (all failed)');
        
        return {
            success: false,
            error: 'ƒê√£ th·ª≠ t·∫•t c·∫£ cookie nh∆∞ng kh√¥ng th√†nh c√¥ng'
        };
    }
    
    /**
     * Get cookie from backend (PREVIEW - kh√¥ng assign)
     */
    async getCookieFromBackend() {
        try {
            // Build URL with query params - d√πng /preview thay v√¨ /guest
            const url = new URL(`${this.backendUrl}/api/cookies/preview`);
            
            // Skip current cookie when retrying
            if (this.currentRetry > 1) {
                url.searchParams.set('skipCurrent', 'true');
                console.log('‚è≠Ô∏è Requesting to skip current cookie');
            }
            
            // Exclude cookies that already failed
            if (this.usedCookies.size > 0) {
                const excludeIds = JSON.stringify([...this.usedCookies]);
                url.searchParams.set('excludeIds', excludeIds);
                console.log(`üö´ Excluding ${this.usedCookies.size} failed cookie(s):`, [...this.usedCookies]);
            }
            
            console.log('üì§ Fetching cookie PREVIEW from:', url.toString());
            console.log('‚ö†Ô∏è Cookie will NOT be assigned until confirmed');
            
            const response = await fetch(url.toString(), {
                method: 'GET',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${this.authToken}`
                }
            });
            
            if (!response.ok) {
                const errorData = await response.json().catch(() => ({}));
                throw new Error(errorData.error || `HTTP ${response.status}`);
            }
            
            const data = await response.json();
            
            if (data.cookie) {
                console.log(`üëÄ Received cookie PREVIEW #${data.cookieNumber} (ID: ${data.cookie._id})`);
                console.log(`üìä Current slots: ${data.sharedUsers}/4 (not incremented yet)`);
                return {
                    cookieId: data.cookie._id || 'unknown',
                    cookieNumber: data.cookieNumber,
                    name: data.cookie.name,
                    value: data.cookie.value,
                    domain: data.cookie.domain,
                    path: data.cookie.path,
                    secure: data.cookie.secure,
                    httpOnly: data.cookie.httpOnly
                };
            }
            
            return null;
            
        } catch (error) {
            console.error('‚ùå Get cookie preview error:', error);
            throw error;
        }
    }
    
    /**
     * Inject cookie and check if login successful
     */
    async injectCookieAndCheck(cookieData) {
        try {
            console.log('üç™ Starting inject cookie process...');
            console.log('üç™ Cookie data:', {
                cookieNumber: cookieData.cookieNumber,
                name: cookieData.name,
                domain: cookieData.domain
            });
            
            // Use existing injectCookieViaExtension function from app.js
            if (typeof window.injectCookieViaExtension !== 'function') {
                console.error('‚ùå injectCookieViaExtension function not found!');
                throw new Error('injectCookieViaExtension function not available');
            }
            
            console.log('üì§ Calling injectCookieViaExtension...');
            const response = await window.injectCookieViaExtension(cookieData);
            console.log('üì• Injection response:', response);
            
            if (!response || !response.success) {
                console.error('‚ùå Injection failed:', response);
                throw new Error(response?.error || 'Extension injection failed');
            }
            
            console.log('‚úÖ Cookie injected successfully, waiting 3s...');
            // Wait for Netflix to process cookie
            await this.sleep(3000);
            
            console.log('üîç Checking login status...');
            // Check login status via extension
            const loginStatus = await this.checkNetflixLoginStatus();
            console.log('üìä Login status:', loginStatus);
            
            return loginStatus;
            
        } catch (error) {
            console.error('‚ùå Inject cookie error:', error);
            return {
                success: false,
                errorCode: 'INJECTION_FAILED',
                error: error.message
            };
        }
    }
    
    /**
     * Check Netflix login status via extension
     * Logic: 
     * 1. N·∫øu URL = /browse ‚Üí Cookie LIVE ‚úÖ
     * 2. N·∫øu c√≥ error NSES-500 ‚Üí Refresh ‚Üí Check l·∫°i
     *    - Sau refresh v√†o /browse ‚Üí Cookie LIVE ‚úÖ
     *    - Sau refresh kh√¥ng v√†o /browse ‚Üí Cookie DIE ‚ùå
     * 3. N·∫øu kh√¥ng ph·∫£i /browse v√† kh√¥ng c√≥ error ‚Üí Cookie DIE ‚ùå
     */
    async checkNetflixLoginStatus() {
        try {
            // Use existing extension communication from app.js
            if (!window.state?.hasExtension || !window.CONFIG?.EXTENSION_ID) {
                return { success: false, errorCode: 'NO_EXTENSION' };
            }
            
            console.log('üîç Checking Netflix login status...');
            
            // Send message to extension to check Netflix tab status
            const response = await chrome.runtime.sendMessage(
                window.CONFIG.EXTENSION_ID,
                { action: 'checkNetflixStatus' }
            );
            
            if (response && response.success) {
                console.log('üìä Login status response:', response.loginStatus, response.url);
                
                // ‚úÖ Case 1: ƒê√£ v√†o /browse ‚Üí Cookie LIVE
                if (response.loginStatus === 'success') {
                    console.log('‚úÖ URL is /browse ‚Üí Cookie LIVE!');
                    return { success: true };
                }
                
                // ‚ö†Ô∏è Case 2: C√≥ error NSES-500 ‚Üí C·∫ßn refresh v√† check l·∫°i
                if (response.loginStatus === 'error') {
                    console.log(`‚ö†Ô∏è Detected error: ${response.errorCode}`);
                    console.log('üîÑ Refreshing page to verify cookie...');
                    
                    // Update progress to show we're refreshing
                    if (window.showStepStatus) {
                        window.showStepStatus(2, 'warning', `üîÑ Ph√°t hi·ªán l·ªói ${response.errorCode}, ƒëang refresh ƒë·ªÉ ki·ªÉm tra...`);
                    }
                    
                    // Refresh v√† check l·∫°i
                    const refreshResult = await this.refreshAndRecheck();
                    
                    if (refreshResult.success) {
                        console.log('‚úÖ Sau refresh v√†o /browse ‚Üí Cookie LIVE!');
                        return { success: true };
                    } else {
                        console.log('‚ùå Sau refresh v·∫´n kh√¥ng v√†o /browse ‚Üí Cookie DIE!');
                        return {
                            success: false,
                            errorCode: response.errorCode || 'NETFLIX_ERROR'
                        };
                    }
                }
                
                // ‚ùå Case 3: Kh√¥ng v√†o /browse v√† kh√¥ng c√≥ error ‚Üí Cookie DIE
                console.log('‚ùå Not at /browse and no specific error ‚Üí Cookie DIE!');
                return {
                    success: false,
                    errorCode: 'NOT_BROWSING'
                };
            }
            
            // Fallback: extension kh√¥ng tr·∫£ l·ªùi ho·∫∑c l·ªói
            console.warn('‚ö†Ô∏è No valid response from extension');
            return {
                success: false,
                errorCode: 'NO_RESPONSE'
            };
            
        } catch (error) {
            console.error('‚ùå Check login status error:', error);
            return {
                success: false,
                errorCode: 'CHECK_FAILED',
                error: error.message
            };
        }
    }
    
    /**
     * Refresh Netflix page and recheck status
     */
    async refreshAndRecheck() {
        try {
            console.log('üîÑ Refreshing Netflix page...');
            
            // Send refresh command to extension
            const refreshResponse = await chrome.runtime.sendMessage(
                window.CONFIG.EXTENSION_ID,
                { action: 'refreshNetflixTab' }
            );
            
            if (!refreshResponse?.success) {
                console.warn('‚ö†Ô∏è Failed to refresh Netflix tab');
                return { success: false, errorCode: 'REFRESH_FAILED' };
            }
            
            // Wait for page to load
            console.log('‚è≥ Waiting for page to reload...');
            await this.sleep(5000); // Wait 5 seconds for page to fully load
            
            // Check status again
            console.log('üîç Checking status after refresh...');
            const response = await chrome.runtime.sendMessage(
                window.CONFIG.EXTENSION_ID,
                { action: 'checkNetflixStatus' }
            );
            
            if (response && response.success && response.loginStatus === 'success') {
                console.log('‚úÖ Success after refresh!');
                
                // Clear warning message
                if (window.hideStepStatus) {
                    window.hideStepStatus(2);
                }
                if (window.showStepStatus) {
                    window.showStepStatus(2, 'success', '‚úÖ ƒêƒÉng nh·∫≠p th√†nh c√¥ng sau khi refresh!');
                }
                
                return { success: true };
            }
            
            console.log('‚ùå Still failed after refresh');
            return { 
                success: false, 
                errorCode: response?.errorCode || 'STILL_FAILED_AFTER_REFRESH' 
            };
            
        } catch (error) {
            console.error('‚ùå Refresh and recheck error:', error);
            return { 
                success: false, 
                errorCode: 'REFRESH_ERROR',
                error: error.message 
            };
        }
    }
    
    /**
     * Confirm cookie assignment (g·ªçi khi login success)
     * Ch·ªâ khi g·ªçi method n√†y, cookie m·ªõi ƒë∆∞·ª£c g√°n user v√† tƒÉng slot +1
     */
    async confirmCookie(cookieId) {
        try {
            console.log('‚úÖ Confirming cookie assignment...');
            console.log('üç™ Cookie ID:', cookieId);
            
            const response = await fetch(`${this.backendUrl}/api/cookies/confirm`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${this.authToken}`
                },
                body: JSON.stringify({ cookieId })
            });
            
            if (!response.ok) {
                const errorData = await response.json().catch(() => ({}));
                console.warn('‚ö†Ô∏è Failed to confirm cookie:', errorData.error);
                return false;
            }
            
            const data = await response.json();
            console.log('‚úÖ Cookie CONFIRMED successfully!');
            console.log(`üìä Cookie #${data.cookieNumber} - Slots: ${data.sharedUsers}/4`);
            return true;
            
        } catch (error) {
            console.error('‚ùå Confirm cookie error:', error);
            return false;
        }
    }
    
    /**
     * Mark cookie as dead in backend (user endpoint - kh√¥ng c·∫ßn admin)
     */
    async markCookieAsDead(cookieId, errorCode) {
        try {
            console.log(`‚ö†Ô∏è Reporting failed cookie to backend...`);
            console.log(`üç™ Cookie ID: ${cookieId}`);
            console.log(`‚ùå Error code: ${errorCode}`);
            
            const response = await fetch(`${this.backendUrl}/api/cookies/${cookieId}/report-failed`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${this.authToken}`
                },
                body: JSON.stringify({
                    errorCode: errorCode || 'UNKNOWN'
                })
            });
            
            if (response.ok) {
                const data = await response.json();
                console.log(`‚úÖ Cookie #${data.cookieNumber} marked as failed (die, recheck)`);
                console.log(`‚ö†Ô∏è Cookie NOT assigned - slot unchanged`);
                console.log(`üìù Status: isActive=false`);
            } else {
                const errorData = await response.json().catch(() => ({}));
                console.warn(`‚ö†Ô∏è Failed to mark cookie as dead:`, errorData.error || response.status);
            }
            
        } catch (error) {
            console.error('‚ùå Mark cookie as dead error:', error);
        }
    }
    
    /**
     * Release cookie from user (khi h·∫øt retries)
     */
    async releaseCookie() {
        try {
            console.log('üîì Releasing failed cookie assignment from user...');
            const response = await fetch(`${this.backendUrl}/api/cookies/release`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${this.authToken}`
                }
            });
            
            if (response.ok) {
                console.log('‚úÖ Cookie released successfully');
            } else {
                console.warn('‚ö†Ô∏è Failed to release cookie:', response.status);
            }
            
        } catch (error) {
            console.error('‚ùå Release cookie error:', error);
        }
    }
    
    /**
     * Sleep helper
     */
    sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }
}

// Export for use in app.js
window.CookieRetryHandler = CookieRetryHandler;

